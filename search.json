[{"title":"前端优化之旅（一）：HTTP请求与Webpack","url":"/2019/08/10/betterWebOne/","content":"\n## 前端优化之旅（一）\n\n本章是前端优化之旅的第一章，我会从网络层来分析我们能干点什么？\n对于网络层前端能做的优化主要就是\n- 减少请求次数\n- 减少单次请求的时间减少阻塞\n\n而这就指向了我们最常见的两种操作，对于资源的压缩与合并，我相信大家对这两个字眼应该不算陌生。不论是使用gulp还是webpack甚至于手动去压缩文件，我们的目的都是为了使得文件变得更少，更小。目前前端领域使用最多同时最广的应该就是Webpack了，我们一起来看看webpack能为我们做些什么吧？\n\n### 减少loader的任务量（以babel-loader为例）\n\n```\nmodule: {\n  rules: [\n    {\n      test: /\\.js$/,\n      exclude: /(node_modules|bower_components)/,\n      use: {\n        loader: 'babel-loader?cacheDirectory=true',\n        options: {\n          presets: ['@babel/preset-env']\n        }\n      }\n    }\n  ]\n}\n```\n这里忽视了node_modules以及bower_components的处理，同时开启了文件的缓存，这样能够大大提升babel-loader的效率\n\n### 缓存第三方类库\n\n在我们实际开发中，一旦项目定型后续的开发或者迭代，对于第三方类库的引用其实是趋于稳定的几乎不会有很大的变动，但是在我们每次打包上线的时候，常常会重复的去对这些第三方类库进行打包，本来这些类库由于嵌套或者引用就很庞大，使得我们需要花很多时间去做这样一个重复的事，这里推荐使用DllPlugin插件来处理这些第三方类库，他的思想就是把这些第三方类库集中在一起，只有在你自身依赖发生改变的时候才会重新打包，这样就大大的提升了我们再打包时候效率,这里推荐大家一篇文章详细的讲解的[DllPlugin的使用][1]\n\n\n### 利用多核进行打包\n\n这里推荐的插件就是Happypack，他是利用CPU的多核优势，把任务分配给多个子进程去执行，提升打包的效率\n```\nconst HappyPack = require('happypack')\nconst ThreadPool =  HappyPack.ThreadPool({ size: os.cpus().length })\nmodule.exports = {\n  module: {\n    rules: [\n      ...\n      {\n        test: /\\.js$/,\n        loader: 'happypack/loader?id=happyBabel',\n        ...\n      },\n    ],\n  },\n  plugins: [\n    ...\n    new HappyPack({\n      id: 'happyBabel',\n      threadPool: ThreadPool,\n      loaders: ['babel-loader?cacheDirectory']\n    })\n  ],\n}\n```\n\n### 忽视未使用的模块\n\n在我们开发过程中其实很多时候会在模块中写一些无用的模块引入，这部分内容不会生效，但是如果也打包进文件，其实也是扩大了文件的体积，这里可以用时Tree_Shaking插件，可以再编译的时候记录没有使用的模块，从而在打包的时候去除这些模块的引入\n\n## 以上就是我所了解的webpack相关的内容（后续会持续添加）\n\n[1]:https://www.jianshu.com/p/ec86c9e64560","tags":["前端优化"]},{"title":"前端优化之旅（前言）","url":"/2019/08/10/betterWebBefore/","content":"\n\n## 前言\n\n开始之前我先抛出一道最近很热门的前端面试题\n>在浏览器的地址栏中输入了一个url地址以后发生什么？\n\n这是一道很基础，但是每个前端coder都必须要有所了解的问题，同时本文后续相关的内容也会围绕着这个题目延伸扩展下去。\n\n**答案：**\n>通过DNS将URL地址解析成IP地址，然后通过IP地址进行TCP网络连接，随后向服务器抛出HTTP请求，服务端处理完请求后把数据放在HTTP响应里返回客户端，浏览器获取到响应后解析DOM请求相关的资源然后渲染，最后呈现给用户一个网页。\n\n大致上可以分化成以下几个阶段\n\n- DNS解析\n- TCP链接\n- HTTP请求请求\n- 服务端响应,HTTP响应返回\n- 客服端拿到HTTP响应并且解析响应内容，呈现结果\n\n在这五个阶段都有很多值得去优化的地方，所以后续的内容我会从网络层面、渲染层面以及性能层面三个大方向对前端性能优化进行分析\n","tags":["前端优化"]},{"title":"JavaScript基础","url":"/2019/07/03/JavaScript基础/","content":"## JavaScript基础\n\n### 变量和类型\n\n1.JavaScript规定的几种数据类型\n\n    JavaScript规范中一共定义了七种数据类型，分类基本类型和引用类型。\n    其中基本类型有：String、Number、Boolean、Undefined、Null、Symbol（es6）\n    引用数据类型：Object\n\n2.JavaScript对象的底层数据结构是什么\n\n    在JavaScript中Object底层是使用FixedArray，一种类数组的方式来实现的，通过记录JSON数据格式的数据中的index与value来记录数据。这里推荐李银城大佬的博文，讲解的很详细。\n[从Chrome源码看JS Object的实现][1]\n\n3.Symbol类型在实际开发中的应用？如何可手动实现一个简单的Symbol？\n\n首先我们先简单的看看Symbol的用法\n```\n<!-- Symbol() -->\nlet s1=Symbol('symbol');\nlet s2=Symbol('symbol');\n\n  s1==s2 //false\n\n  s1.toString() // \"Symbol(symbol)\" \n  s2.toString() // \"Symbol(symbol)\"\n\n  <!-- Symbol.for() -->\n\nlet s3=Symbol.for('symbol')\nlet s4=Symbol.for('symbol')\n\ns3===s4 //true\n\n<!-- 隐式调用toString方法 -->\n\nconst returnString={\n    toString(){\n        return 'testSymbol'\n    }\n}\n\nlet sbl=Symbol(returnString);\n\nsbl //testSymbol\n\n<!-- 对Symbol类型的转换 -->\n\nBoolean(Symbol())//true\n\nNumber(Symbol()) // TypeError\n\n<!-- Symbol在对象中的使用 -->\nlet symbolKey=Symbol();\n\nlet obj={}\nobj[symbolKey]='123';\n\n//  or\nlet obj={\n    [symbolKey]:'123'\n}\n\n// or\nlet obj = {};\nObject.defineProperty(obj, symbolKey, { value: '123' });\n\n\nobj[symbolKey] //123\n\n```\n\n    场景一：使用Symbol来做对象的属性名。\n    \n    使用Symbol来做属性名时是没办法被Object.keys或者for in来枚举，就算使用JSON.stringify对其打印显示的也只是一个空对象\n\n    Ps:但是不是真的无法获取以Symbol方式定义的对象属性，例如使用Object.getOwnPropertySymbols(obj) ，Reflect.ownKeys(obj)  仍然是可以拿到对象属性。\n\n    场景二：使用Symbol来代替常量\n    因为Symbol的唯一性所以在命名一些常量时，其本身就是唯一的，减少命名的冲突\n\n\n\n\n\n\n\n\n[1]:https://www.rrfed.com/2017/04/04/chrome-object/\n  ","tags":["javaScript"],"categories":["javaScript"]},{"title":"React之ExpirationTime","url":"/2019/06/25/React之ExpirationTime/","content":"\n# **简析React源码之ExpirationTime**\n\n## 前言\n\n熟悉React的朋友都知道如果在组件内使用setState会创建一个Update从而导致页面重新渲染，那么理论上如果有多个setState就会导致多次渲染，那么问题来了，实际真的是这个样的吗？\n\n## 演示Demo\n首先我们先简单的建立一个demo\n``` Code Block\nimport React, { Component } from 'react';\n\nclass App extends Component {\n  static state = {\n    name: 1\n  }\n  constructor(props) {\n    super(props)\n    this.state = {\n      number: 10000\n    }\n  }\n  componentDidMount() {\n    this.setState({\n      number: 10001\n    })\n    this.setState({\n      number: 10002\n    })\n    this.setState({\n      number: 10003\n    })\n  }\n  render() {\n    const { number } = this.state;\n    console.log('rendering')\n    return (\n      <div>\n        我的编号是：{number}\n      </div>\n    )\n  }\n}\n\nexport default App;\n\n```\n\n可见在这个demo中componentDidMount中连续执行了三次setState，那么加上初始化渲染执行的一次render函数，理论上在控制台中应该会打印四次rendering，但是事实真的是这样吗？\n\n\n![显示效果图](React之ExpirationTime/ExpirationTime.png)\n<center> <图1> 控制台</center>\n\n纳尼！怎么只打印了两次呢？emmmm，这里就引出了React中一个概念了，ExpirationTime即到期时间。\n## 源码分析\n本章代码主要来源于ReactFiberExpirationTime.js文件。\n\n#### 示例demo代码\n```Code Block\n<!-- 示例demo代码 -->\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n// import MAX_SIGNED_31_BIT_INT from './maxSigned31BitInt';\n\nconst MAX_SIGNED_31_BIT_INT = 1073741823\n\n// type ExpirationTime = number;\n\nconst NoWork = 0;\nconst Never = 1;\nconst Sync = MAX_SIGNED_31_BIT_INT;\n\nconst UNIT_SIZE = 10\nconst MAGIC_NUMBER_OFFSET = MAX_SIGNED_31_BIT_INT - 1;\n\n// 1 unit of expiration time represents 10ms.\nfunction msToExpirationTime(ms) {\n  // Always add an offset so that we don't clash with the magic number for NoWork.\n  return  MAGIC_NUMBER_OFFSET - ((ms / UNIT_SIZE) | 0)\n}\n\nfunction expirationTimeToMs(expirationTime) {\n  return (MAGIC_NUMBER_OFFSET - expirationTime) * UNIT_SIZE;\n}\n\n// \nfunction ceiling(num, precision) {\n  return (((num / precision) | 0) + 1) * precision\n}\n\nfunction computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {\n  return (\n    MAGIC_NUMBER_OFFSET -\n    ceiling(\n      MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE,\n      bucketSizeMs / UNIT_SIZE,\n    )\n  )\n}\n\nconst LOW_PRIORITY_EXPIRATION = 5000\nconst LOW_PRIORITY_BATCH_SIZE = 250\n\nfunction computeAsyncExpiration(currentTime) {\n  return computeExpirationBucket(\n    currentTime,\n    LOW_PRIORITY_EXPIRATION,\n    LOW_PRIORITY_BATCH_SIZE,\n  )\n}\n// (1073741822-(((1073732322 / 25) | 0) + 1) * 25)\n\nconst HIGH_PRIORITY_EXPIRATION = 500\nconst HIGH_PRIORITY_BATCH_SIZE = 100\n\nfunction computeInteractiveExpiration(currentTime) {\n  return computeExpirationBucket(\n    currentTime,\n    HIGH_PRIORITY_EXPIRATION,\n    HIGH_PRIORITY_BATCH_SIZE,\n  )\n}\n// (1073741822-(((1073731872 / 10) | 0) + 1) * 10)\n\nconsole.log(computeInteractiveExpiration(10000))\nconsole.log(computeAsyncExpiration(10000))\nconsole.log('=======')\nconsole.log(computeInteractiveExpiration(10002))\nconsole.log(computeAsyncExpiration(10010))\nconsole.log('=======')\nconsole.log(computeInteractiveExpiration(10004))\nconsole.log(computeAsyncExpiration(10020))\nconsole.log('=======')\nconsole.log(computeInteractiveExpiration(10006))\nconsole.log(computeAsyncExpiration(10030))\n```\n\n![显示效果图](React之ExpirationTime/ExpirationTimeshow.png)\n<center> <图2> 执行结果</center>\n\n- 我们这里主要执行的是computeInteractiveExpiration函数与computeAsyncExpiration，他们在React中对应的是两类ExpirationTime，一个是Interactive（交互式，例如：由事件触发）另一个是async（异步式，例如：setState ）\n\n- 这里特别强调一下，computeInteractiveExpiration与computeAsyncExpiration几乎无异，两者之只不过在传递参数上大小略有不同，<span style='color:green'>**computeInteractiveExpiration**</span>传递的是**HIGH_PRIORITY_EXPIRATION**（500）跟**HIGH_PRIORITY_BATCH_SIZE**（100），而<span style='color:red'>**computeAsyncExpiration**</span>传递的则是**LOW_PRIORITY_EXPIRATION**(5000)跟**LOW_PRIORITY_BATCH_SIZE**（250），根据以上代码中的公式可以得知传递的参数越大得到的expirationTime也会越大，也就是说 交互的优先级高于异步式，computeInteractiveExpiration的更新优先级高于computeAsyncExpiration。\n- 根据图二可以得知，在computeInteractiveExpiration函数中区间在10以内的获取的ExpirationTime相同，computeAsyncExpiration函数中区间为25以内获取的ExpirationTime相同。如果不同的Update获取到的ExpirationTime相同，那么React则会认为把它整合为同一个Update一次性更新，避免因为不必要的重复渲染导致性能问题。这也就是为什么在控制台中只打印出了两次rendering的原因。\n","tags":["React"],"categories":["React"]},{"title":"React之ReactChildren.js","url":"/2019/06/11/React之ReactChildrenJs/","content":"\n# **简析React源码之ReactChildren.js**\n\n## 前言\n近来一直在研究React源码以及实现的原理，这一章的内容主要是分析ReactChildren.js的代码，以及实现的功能。本文的代码是基于Reactv16.6.3版本，详细的代码[React][1]源码可以去github下载，同时本章的示例代码可以通过我的github下载学习[示例代码][2]。本章主要是简析React源码中的ReactChildren.js文件，原始代码请参考react/src/ReactChildren.js文件，本章只是针对功能函数进行分析，代码可能略有缺失，完整代码请参考源码。\n\n## 演示Demo\n\n``` Code Block\nimport React from 'react';\nfunction ReactChildrenDemo(props){\n    conosle.log(props.children);\n    console.log(React.Children.map(props.children),child=>[child,[child,child]])\n    return props.children\n}\n\nexport default ()=>(\n    <ReactChildrenDemo>\n        <span>demo1</span>\n        <span>demo1</span>\n    </ReactChildrenDemo>\n)\n```\n\n<center>示例模块</center>\n\n![显示效果图](React之ReactChildrenJs/flow.png)\n<center> <图1> Rmap函数流程图</center>\n\n## 代码分析\n本章主要以React.Chilren提供的map函数来分析ReactChildren.js文件。\n\n#### 示例demo代码\n```Code Block\n<!-- 示例demo代码 -->\nimport React from 'react';\nfunction ReactChildrenDemo(props){\n    conosle.log(props.children);\n    console.log(React.Children.map(props.children),c=>[c,[c,c]])\n    return props.children\n}\nexport default ()=>(\n    <ReactChildrenDemo>\n        <span>demo1</span>\n        <span>demo1</span>\n    </ReactChildrenDemo>\n)\n```\n```Code Block\n<!-- ReactChildren.js -->\nexport {\n  forEachChildren as forEach,\n  mapChildren as map,\n  countChildren as count,\n  onlyChild as only,\n  toArray,\n};\n```\n\n- React.Children提供的map函数很容易让人联想到Array提供的map函数，但是两者实质上并不相同，入参以及返回的数据也不同。这里以<span style='color:red'>**Rmap**</span>代称呼React.Children提供的map函数，Rmap入参需要三个 props.children、遍历的traverse函数、执行Rmap操作的环境context。\n\n#### mapChildren函数\n```Code Block\n<!-- mapChildren函数 -->\n\n/**\n * map遍历的children一定要为`props.children`\n *\n *\n * @param {?*} children 传递进来的props.children.\n * @param {function(*, int)} func 为传递进来的遍历函数.\n * @param {*} context Rmap函数执行的上下文.\n * @return {object} 函数执行返回的结果\n */\n\n// 实际的map函数\nfunction mapChildren(children, func, context) {\n    if (children === null) {\n        return children;\n    }\n    const result = [];\n    mapIntoWithKeyPrefixInternal(children, result, null, func, context);\n}\n```\n\n- 这里需要注意的是props.children可能存在三种值;\n    - 如果当前组件没有子节点，它就是undefined;\n    - 如果有一个子节点，数据类型是Object;\n    - 如果有多个子节点，数据类型就是array;\n\n- 只有传递进来的children不为null的时候才会进入到mapIntoWithKeyPrefixInternal函数内\n\n#### mapIntoWithKeyPrefixInternal函数\n\n```Code Block\n<!-- mapIntoWithKeyPrefixInternal函数 -->\n\nfunction mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {\n    // key相关，字符串处理\n    let escapedPrefix = '';\n    if (prefix != null) {\n        escapedPrefix = escapeUserProvidedKey(prefix) + '/';\n    }\n    const traverseContext = getPooledTraverseContext(\n        array,\n        escapedPrefix,\n        func,\n        context\n    )\n    traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);\n    releaseTraverseContext(traverseContext);\n    // 清除对象的属性，如果没超过对象池则在对象池中添加该对象\n}\n```\n\n#### getPooledTraverseContext函数\n\n```Code Block\n<!-- getPooledTraverseContext函数 -->\n\nconst traverseContextPool = [];\nconst POOL_SIZE = 10;\nfunction getPooledTraverseContext(\n  mapResult,\n  keyPrefix,\n  mapFunction,\n  mapContext,\n) {\n  if (traverseContextPool.length) {\n    const traverseContext = traverseContextPool.pop();\n    traverseContext.result = mapResult;\n    traverseContext.keyPrefix = keyPrefix;\n    traverseContext.func = mapFunction;\n    traverseContext.context = mapContext;\n    traverseContext.count = 0;\n    return traverseContext;\n  } else {\n    return {\n      result: mapResult,\n      keyPrefix: keyPrefix,\n      func: mapFunction,\n      context: mapContext,\n      count: 0,\n    };\n  }\n}\n```\n\n#### releaseTraverseContext函数\n\n```Code Block\n<!-- releaseTraverseContext函数 -->\n\nfunction releaseTraverseContext(traverseContext) {\n    traverseContext.result = null;\n    traverseContext.keyPrefix = null;\n    traverseContext.func = null;\n    traverseContext.context = null;\n    traverseContext.count = 0;\n    if (traverseContextPool.length < POOL_SIZE) {\n        traverseContextPool.push(traverseContext);\n    }\n}\n```\n\n- 这里主要是负责处理key相关以及遍历children的操作，同时这里应用了一个对象池的概念。\n    - **对象池**：简单点说就是因为js如果大量的创建对象，使用完后再销毁对象，其实是一件非常影响性能的事情，所以引入一个对象池的概念，在对象池中创建一定的对象，每次使用完毕后讲对象变成未激活状态来代替销毁对象，这样能够保持浏览器的性能，同时也是避免大量对象的创建以及销毁带来的内存抖动。\n- 这里的**getPooledTraverseContext**函数就是这样的一个负责从对象池中获取对象的函数。\n    - 如果在执行时判定如果对象池traverseContextPool为空则会创建一个新的对象并且返回。\n    - 如果在执行时判定如果对象池traverseContextPool不为空，则会取出最后一个对象并且返回。\n- 当执行完traverseAllChildren这个真正跟Rmap相关的函数以后就会执行**releaseTraverseContext**函数，该函数主要负责的就是将对象清空也就是变成为激活状态，并且会判定当前对象池中是否已经超过了设定的最大容量如果没有则会向对象池中塞入该未激活状态的对象。\n\n#### traverseAllChildren（traverseAllChildrenImpl）函数\n\n```Code Block\n<!-- traverseAllChildren函数 -->\n/**\n *\n *\n * @param {*} children 传递的props.children\n * @param {*} callback 为传递进来的mapSingleChildIntoContext函数\n * @param {*} traverseContext 从对象池中获取的对象，也是执行的上下文\n * @returns\n */\nfunction traverseAllChildren(children, callback, traverseContext) {\n    if (children == null) {\n        return 0;\n    }\n    return traverseAllChildrenImpl(children, '', callback, traverseContext);\n}\n\n<!-- traverseAllChildrenImpl函数 -->\n\n/**\n *\n *\n * @param {*} children  初始值 props.children，后续为递归传递的子节点\n * @param {*} nameSoFar 初始值 ''\n * @param {*} callback  mapSingleChildIntoContext\n * @param {*} traverseContext 这里的context为对象池中获取的对象\n */\nfunction traverseAllChildrenImpl(\n    children,\n    nameSoFar,\n    callback,\n    traverseContext,\n) {\n    const type = typeof children;\n    let invokeCallback = false;\n\n    if (type === \"undefined\" || type === \"boolean\") {\n        invokeCallback = true;\n    } else {\n        switch (type) {\n            case 'string':\n            case 'number':\n                invokeCallback = true;\n                break;\n            case 'object':\n                switch (children.$$typeof) {\n                    case REACT_ELEMENT_TYPE:\n                    case REACT_PORTAL_TYPE:\n                        invokeCallback = true;\n                }\n        }\n    }\n\n    if (invokeCallback) {\n        callback(\n            traverseContext,\n            children,\n            nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar,\n        );\n        return 1;\n    }\n\n    let child;\n    let nextName;\n    let subtreeCount = 0;\n    const nextNamePrefix =\n        nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;//初始值为'.:'\n    if (Array.isArray(children)) {\n        for (let i = 0; i < children.length; i++) {\n            child = children[i];\n            nextName = nextNamePrefix + getComponentKey(child, i);\n            subtreeCount += traverseAllChildrenImpl(\n                child,\n                nextName,\n                callback,\n                traverseContext,\n            );\n        }\n    } else {\n        const iteratorFn = getIteratorFn(children);\n        if (typeof iteratorFn === 'function') {\n            const iterator = iteratorFn.call(children);\n            let step;\n            let ii = 0;\n            while (!(step = iterator.next()).done) {\n                child = step.value;\n                nextName = nextNamePrefix + getComponentKey(child, ii++);\n                subtreeCount += traverseAllChildrenImpl(\n                    child,\n                    nextName,\n                    callback,\n                    traverseContext,\n                );\n            }\n        } else if (type === 'object') {\n            let addendum = '';\n            const childrenString = '' + children;\n            invariant(\n                false,\n                'Objects are not valid as a React child (found: %s).%s',\n                childrenString === '[object Object]'\n                    ? 'object with keys {' + Object.keys(children).join(', ') + '}'\n                    : childrenString,\n                addendum,\n            );\n        }\n    }\n    return subtreeCount;\n}\n\nconst POOL_SIZE = 10;\nconst traverseContextPool = [];\nfunction getPooledTraverseContext(\n  mapResult,\n  keyPrefix,\n  mapFunction,\n  mapContext,\n) {\n  if (traverseContextPool.length) {\n    const traverseContext = traverseContextPool.pop();\n    traverseContext.result = mapResult;\n    traverseContext.keyPrefix = keyPrefix;\n    traverseContext.func = mapFunction;\n    traverseContext.context = mapContext;\n    traverseContext.count = 0;\n    return traverseContext;\n  } else {\n    return {\n      result: mapResult,\n      keyPrefix: keyPrefix,\n      func: mapFunction,\n      context: mapContext,\n      count: 0,\n    };\n  }\n}\n```\n- traverseAllChildren函数并没有多大意义，主要执行的函数是traverseAllChildrenImpl函数。\n- traverseAllChildrenImpl接收四个参数。\n    - children 初始值 props.children，后续为递归传递的子节点\n    - nameSoFar 初始值 '' key相关\n    - callback 初始值为 mapSingleChildIntoContext\n    - traverseContext 为对象池中获取的对象\n- 只有当传递的children为**数组**时，会进行遍历操作，生成新的namePrefix以及subtreeCount进行计数（key相关）。同时在调用自身（traverseAllChildrenImpl）函数执行一个大的递归操作，只有当传递进函数的children为**单节点**同时为React可以解析的数据类型（undefined、boolean、string、number以及object）时才会执行callback函数也就是mapSingleChildIntoContext函数\n\n#### mapSingleChildIntoContext函数\n```Code Block\n<!-- mapSingleChildIntoContext函数 -->\n/**\n *\n *\n * @param {*} bookKeeping 为poolContext中获取的对象\n * @param {*} child 传递的单节点\n * @param {*} childKey 节点key\n */\nfunction mapSingleChildIntoContext(bookKeeping, child, childKey) {\n    const {result, keyPrefix, func, context} = bookKeeping;\n  \n    let mappedChild = func.call(context, child, bookKeeping.count++);\n    if (Array.isArray(mappedChild)) {\n      mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, c => c);\n    } else if (mappedChild != null) {\n      if (isValidElement(mappedChild)) {\n        mappedChild = cloneAndReplaceKey(\n          mappedChild,\n          // Keep both the (mapped) and old keys if they differ, just as\n          // traverseAllChildren used to do for objects as children\n          keyPrefix +\n            (mappedChild.key && (!child || child.key !== mappedChild.key)\n              ? escapeUserProvidedKey(mappedChild.key) + '/'\n              : '') +\n            childKey,\n        );\n      }\n      result.push(mappedChild);\n    }\n  }\n\n```\n- mapSingleChildIntoContext接受三个参数bookKeeping（为poolContext中获取的对象）、children为props.Children获取的单一节点、childrenKey为key相关。\n- mappedChild为Rmp传递进的递归函数生成的数据，如果mappedChild生成的数据为数组则会再调用mapIntoWithKeyPrefixInternal函数执行递归操作，如果不是则会判定是否为React元素如果为React元素则会克隆元素并且塞入result中（引用传递）\n\n#### forEach、count、only以及toArray\n\n- forEach与toArray跟map函数大体相同只是调用的callback函数不同，利用引用传递同时有无返回数据的不同\n- only 判定是否为单一节点\n- count 判定子节点的个数\n\n具体API的解析可以参考[ReactApi文档][3]\n\n[1]: https://github.com/facebook/react.git\n[2]: https://github.com/wilesen/BlogProject.git\n[3]: https://zh-hans.reactjs.org/docs/react-api.html#reactchildrenmap","tags":["React"],"categories":["React"]},{"title":"走近React的第三天（模拟React的生命周期）","url":"/2019/05/05/ApproachingReactThree/","content":"\n# **抽离代码&&模拟React的生命周期** \n\n这一章的目标是抽离《走近React的第二天》中可复用的代码部分同时模拟React的部分基础生命周期，这里你需要对React的生命周期有一点基础的了解，明白每个周期的作用，这样才能方便你去学习这一章的内容。\n\n## **目标**\n\n- 抽离可复用代码\n\n- 模拟React部分生命周期\n\n### **React生命周期**\nReact提供的生命周期在React实际开发过程中是十分重要的，网上已经有很多关于React的生命周期的介绍，就不过多的赘述了，这里分享几个我觉得不错的介绍[详解React生命周期][1]、[React 生命周期][2]。\n\n![显示效果图](ApproachingReactThree/React生命周期.jpg)\n**<center>（图一：React生命周期）</center>**\n\n![显示效果图](ApproachingReactThree/theLifeCycle.gif)\n**<center>（图二：效果图）</center>**\n\n\n## **实现方案**\n- 首先在父组件<span style=\"color:green\">**Component**</span>中抽离出<span style=\"color:red\">**Render、setState、bindEvent、createDOM**</span>等可复用方法，使得子组件可以通过<span style=\"color:red\">**extends**</span>继承的方式拿到Component中抽离出的方法。\n\n- 在渲染的时候通过判断目前是否已完成渲染<span style=\"color:red\">**（this.$element）**</span>以及调用<span style=\"color:red\">**_createDOM**</span>来进行生命周期的判定。\n\n- componentWillMount&nbsp;&nbsp;&nbsp;该生命周期应该是在组件将要渲染之前触发，所以前置条件是<span style=\"color:red\">**（this.$element）**</span>为undefined且在appendChild方法调用之前触发。\n\n- componentDidMount&nbsp;&nbsp;&nbsp;该生命周期应该是在组件第一次完成渲染之后触发，所以前置条件是<span style=\"color:red\">**（this.$element）**</span>为当前最近的DOM节点的且在appendChild方法调用之后再触发。\n\n- shouldComponentUpdate&nbsp;&nbsp;&nbsp;该生命周期应该是一个比较特殊的生命周期，该生命周期应该是在组件已经完成渲染且State中数据修改之后且该生命周期返回值为<span style=\"color:green\">**true**</span>的时候才会触发,在组件中判定该生命周期返回值为true才会继续完成渲染。\n\n- componentWillUpdate&nbsp;&nbsp;&nbsp;该生命周期应该是在组件已经完成渲染且State中数据修改之后触发，所以前置条件是<span style=\"color:red\">**（this.$element）**</span>已有DOM节点的且在replaceChild方法调用之前再触发\n\n- componentDidUpdate&nbsp;&nbsp;&nbsp;该生命周期应该是在组件已经完成渲染且State中数据修改之后触发，所以前置条件是<span style=\"color:red\">**（this.$element）**</span>已有DOM节点的且在replaceChild方法调用之后再触发\n\n\n### **父组件Component**\n\n```Code Block\n    class Component{\n            constructor(props={}){\n                this.props=props;\n            }\n            setState(nextState){\n                this.state={...this.state,...nextState};\n                this._render();\n            }\n            _createDOM(htmlDom){\n                const fragment = document.createElement('div');\n                fragment.innerHTML = htmlDom;\n                return this._bindEvent(fragment.firstElementChild);          \n            }\n            _bindEvent(el){\n                el.getAttributeNames().forEach(name => {\n                    const matches = name.match(/^on([a-z]+)$/);\n                    matches && el.addEventListener(matches[1], new Function('return ' + el.getAttribute(name)).bind(this)(), false);\n                });\n                Array.from(el.children).forEach( el => this._bindEvent(el));\n                return el;\n            }\n            _render(){\n                const oldElement = this.$element;\n                if (oldElement) {\n                    if(this.shouldComponentUpdate&&!this.shouldComponentUpdate.bind(this)()){\n                        return ;\n                    }\n                    this.componentWillUpdate&&this.componentWillUpdate.bind(this)();\n                    this.$element = this._createDOM(this.render());\n                    this.$container.replaceChild(this.$element, oldElement);\n                    this.componentDidUpdate && this.componentDidUpdate.bind(this)();\n                } else {\n                    this.componentWillMount && this.componentWillMount.bind(this)();\n                    this.$element = this._createDOM(this.render());\n                    this.$container.appendChild(this.$element);\n                    this.componentDidMount && this.componentDidMount.bind(this)();\n                }\n                return this.$element;\n            } \n        }\n```\n\n\n### **子组件Counter**\n\n```Code Block\n        class  Counter extends Component{\n            constructor(props){\n                super(props);\n                this.state={\n                    dateList:[]\n                }\n                this.add=this.add.bind(this);\n                this.reduce=this.reduce.bind(this);\n            }\n            componentWillMount(){\n                console.log('componentWillMount', this.state);\n            }\n            componentDidMount(){\n                console.log('componentDidMount', this.state);\n            }\n            componentDidUpdate(){\n                console.log('componentDidUpdate', this.state);\n            }\n            shouldComponentUpdate(){\n                return true;\n            }\n            componentWillUpdate(){\n                console.log('componentWillUpdate', this.state); \n            }\n            add(){\n                let newDateList=[...this.state.dateList]\n                newDateList.push(new Date().toString());\n                this.setState({dateList:newDateList});\n            }\n            reduce(){\n                let newDateList=[...this.state.dateList]\n                newDateList.pop();\n                this.setState({dateList:newDateList});\n            }\n            render(){\n                const {dateList}=this.state;\n                const oldElement=this.$element;\n                let color='blue';\n                if (dateList.length >= 5) color = 'red';\n                if (dateList.length <= 0) color = 'green';\n                console.log('render')\n               return (\n                `\n                    <div>  \n                        <div style=\"color:${color}\">当前List条数为 ${dateList.length}</div>\n                        <button onClick=\"this.add\">增加一条</button>\n                        <button onClick=\"this.reduce\">减少一条</button>\n                        <ul>\n                            ${\n                                dateList.map((item,index)=>`<li style=\"color:${color}\">便签${index+1} 时间是：${item}</li>`)\n                            }\n                        </ul>\n                    </div>\n                `\n               )\n            }\n        }\n```\n\n现在回头再看现在的Counter组件，是不是跟使用通过继承React的Component组件的写法已基本无异了，当然这里仅仅只是基础的模拟实现帮助理解学习。[示例源码][3]\n\n[1]:https://www.jianshu.com/p/514fe21b9914\n[2]:https://www.cnblogs.com/qiaojie/p/6135180.html\n[3]:https://github.com/wilesen/BlogProject","tags":["React"],"categories":["React"]},{"title":"走近React的第二天（模拟实现render&&setState方法）","url":"/2019/05/05/ApproachingReactTwo/","content":"\n# **模拟实现React的render以及setState方法**\n\n这一章的主要目标是模拟实现React的render以及setState更新state后刷新DOM的实现，看到这里你需要一点点ES6的基础，如果这里你还不是很会，推荐一下阮一峰老师的[ES6教程][1]写的特别好。\n\n## **目标**\n\n- 模拟实现React的render方法动态的生成Dom元素\n\n- 绑定Dom节点上的函数\n\n- 实现setState操作并且更新数据后运行Render方法重新渲染DOM元素。\n\n**<center>效果图</center>**\n\n![显示效果图](ApproachingReactTwo/todoList2.gif)\n\n<center style=\"color:gray\">(ps： 每条li之间显示的<span style='color:red'> ，</span>是因为对数组对象调用toString方法后导致的，这里就不过多解释了)</center>\n\n## **实现方案**\n\n- 抽离render方法，内部通过innerHtml方法渲染DOM元素<span style='color:gray'>（当然了这里只是简单的模拟，<span style='color:red'>innerHTML</span>方法会重新渲染全部的DOM节点，在数据量大结构复杂的元素需要生成的时候会占用极大的性能，React使用的是<span style='color:red'>VirtualDOM</span>配合<span style='color:red'>diff</span>算法实现的反应更快且占用资源更少，后续会在博客中更新）</span>\n\n- 通过正则表达式解析出自定义特定结构的属性并且在类的内部绑定对应的函数\n\n- 在调用<span style='color:red'>setState</span>方法时同时触发抽离出来的<span style='color:red'>render</span>方法达到重新渲染视图的目的。\n\n\n### **第一步：抽离render方法(用于渲染DOM元素)**\n\n<span style='color:green'>**（解析）:**</span>遍历存在state中的dateList数组动态的生成对应的 <span style='color:green'>`<li></li>`</span> 元素结构动态，然后在判断触发render方法时，该模块是否已经存在Dom结构，如果存在则替换现有DOM结构，反之则插入DOM结构\n```Code block\n    createDOM(htmlDom){\n                const fragment = document.createElement('div');\n                fragment.innerHTML = htmlDom; \n                return this.bindEvent(fragment.firstElementChild);\n    }\n ```\n\n ```Code block\n    render(){\n                const {dateList}=this.state;\n                const oldElement=this.$element;\n                let color='blue';\n                if (dateList.length >= 5) color = 'red';\n                if (dateList.length <= 0) color = 'green';\n                this.$element = this.createDOM(`\n                    <div>  \n                        <div style=\"color:${color}\">当前List条数为 ${dateList.length}</div>\n                        <button onClick=\"this.add\">增加一条</button>\n                        <button onClick=\"this.reduce\">减少一条</button>\n                        <ul>\n                            ${\n                                dateList.map((item,index)=>`<li style=\"color:${color}\">便签${index+1} 时间是：${item}</li>`)\n                            }\n                        </ul>\n                    </div>\n                `);\n                this.$container[oldElement ? 'replaceChild' : 'appendChild'](this.$element, oldElement);\n                return this.$element;\n        }\n```\n\n### **第二步：解析属性并绑定对应函数**\n\n<span style='color:green'>**（解析）:**</span>对传入的DOM结构进行递归操作，通过正则表达式解析元素的自定义的属性,通过<span style='color:red'>**addEventListener**</span>方法绑定对应的函数\n\n```Code block\n        bindEvent(el){\n                el.getAttributeNames().forEach(name => {\n                    const matches=name.match(/^on([a-z]+)$/);\n                    matches && el.addEventListener(matches[1], new Function('return ' + el.getAttribute(name)).bind(this)(),false);\n                });\n                Array.from(el.children).forEach(el=>this.bindEvent(el));\n                return el;\n            }\n```\n\n### **第三步：调用setState方法并触发Render方法重新渲染**\n\n<span style='color:green'>**（解析）:**</span>使用<span style='color:red'> **Object.assign**</span>方法或操作符<span style='color:red'> **(...)** </span>方法将存在state中的数据跟传递过来新的数据合并，同时再调用<span style='color:red'> **render** </span>方法触发页面的DOM结构的重新渲染\n\n```Code block\n        setState(nextState){\n            this.state={...this.state,...nextState};\n            this.render();\n            }\n```\n\n这样基本就能够完成制定的三个目标了。\n\n### **完整的代码**\n\nhtml部分：\n\n```Code block\n\n<div id=\"root\"></div>\n```\n\nJavaScript部分：\n```Code block\nfunction mountNode(counter, root){\n            (counter.$container = root).appendChild(counter.render());\n        }\n        class  Counter{\n            constructor(){\n                this.state={\n                    dateList:[]\n                }\n                this.add=this.add.bind(this);\n                this.reduce=this.reduce.bind(this);\n            }\n            add(){\n                let newDateList=[...this.state.dateList]\n                newDateList.push(new Date().toString());\n                this.setState({dateList:newDateList});\n            }\n            reduce(){\n                let newDateList=[...this.state.dateList]\n                newDateList.pop();\n                this.setState({dateList:newDateList});\n            }\n            bindEvent(el){\n                el.getAttributeNames().forEach(name => {\n                    const matches=name.match(/^on([a-z]+)$/);\n                    matches && el.addEventListener(matches[1], new Function('return ' + el.getAttribute(name)).bind(this)(),false);\n                });\n                Array.from(el.children).forEach(el=>this.bindEvent(el));\n                return el;\n            }\n            setState(nextState){\n                this.state={...this.state,...nextState};\n                this.render();\n            }\n            createDOM(htmlDom){\n                const fragment = document.createElement('div');\n                fragment.innerHTML = htmlDom; \n                return this.bindEvent(fragment.firstElementChild);\n            }\n            render(){\n                const {dateList}=this.state;\n                const oldElement=this.$element;\n                let color='blue';\n                if (dateList.length >= 5) color = 'red';\n                if (dateList.length <= 0) color = 'green';\n                this.$element = this.createDOM(`\n                    <div>  \n                        <div style=\"color:${color}\">当前List条数为 ${dateList.length}</div>\n                        <button onClick=\"this.add\">增加一条</button>\n                        <button onClick=\"this.reduce\">减少一条</button>\n                        <ul>\n                            ${\n                                dateList.map((item,index)=>`<li style=\"color:${color}\">便签${index+1} 时间是：${item}</li>`)\n                            }\n                        </ul>\n                    </div>\n                `);\n                this.$container[oldElement ? 'replaceChild' : 'appendChild'](this.$element, oldElement);\n                return this.$element;\n            }\n        }\n        mountNode(new Counter(),document.getElementById('root'));\n```\n\n### **代码抽离&&优化**\n\n看到这里可能，有一定抽象能力的客官可能会质疑了，《走近React的第一天》说好的代码抽离呢，你这也没有抽离啊！不就是简单的整合功能实现了一下功能吗，代码复用性还是不够啊？别别别，客官别急，咱们第三章会细细道来。[示例源码][2]\n\n\n[1]:http://es6.ruanyifeng.com/\n[2]:https://github.com/wilesen/BlogProject\n","tags":["React"],"categories":["React"]},{"title":"走近React的第一天（一个简单的TodoList例子）","url":"/2019/04/28/ApproachingReactOne/","content":"\n## 走近React的第一天（一个简单的TodoList例子） \n\n## 前言\nReact.js是一个专注于构建视图层的JavaScript库，使用它你可以非常轻松地创建你需要的用户交互界面。为你应用的每一个状态设计简洁的视图，在数据改变时 React 也可以高效地更新渲染界面。本文仅仅只是帮组自己跟React初学者进一步的去理解学习React内部实现原理并记录的过程，对于React的具体学习教程可参考[React中文网][1],这里就不过多的赘述了。\n\n## 目标\n\n这一章的目标是实现一个动态增减列表的ToDoList实例。\n\n**<center>先上效果图</center>**\n![显示效果图](ApproachingReactOne/toDoList.gif)\n\n我相信有一定基础的前端coder对于实现这个效果都是顺手拈来的。\n\n#### **html部分**\n\n对页面结构添加一定的 HTML 结构\n\n```Code Block\n    <div id=\"root\">\n        <button id='add'>增加一条</button>\n        <button id='reduce'>减少一条</button>\n        <ul id='list' ></ul>\n    </div>\n```\n\n#### **js部分**\n\n加入以下JavaScript的Dom操作\n\n```Code Block\n        const UL=document.getElementById('list');\n        const add= document.getElementById('add');\n        const reduce= document.getElementById('reduce');\n        let num=0;\n        let Arr=[];\n        add.addEventListener('click',()=>{\n            let OL=document.createElement(\"ol\");\n            let TEXT=document.createTextNode(`这里是我第${num+1}条需要做的`);\n            OL.appendChild(TEXT);\n            UL.appendChild(OL)\n            num++;     \n        })\n        reduce.addEventListener('click',()=>{    \n            if(UL.children.length){\n                UL.removeChild(UL.children[UL.children.length-1]);\n                num--;\n            }\n        })\n```\n\n功能和实现都很简单，到这里实例已经可以简单的实现List的增加和减少了。\n\n毫无疑问这样的代码可谓是言简意赅，很容易就能看懂每一段代码的具体目的，但是这样的代码在开发过程中的效率是很低的，没有什么复用性。如果这个时候PM过来找你说，’咱们现在不做ToDoList了，我们来做一个点赞评价模块‘，那么很不幸这块代码可能就需要全部推翻重写，对于咱们码农来说这样又平白无故的增加了不少工作量。那么我们能不能去把这些代码去抽离一下呢？客官别急，咱们后续慢慢看来！[示例源码][2]\n\n[1]: https://react.docschina.org/\n[2]:https://github.com/wilesen/BlogProject","tags":["React"],"categories":["React"]},{"title":"EggJs单页面应用的基本实现","url":"/2019/04/12/EggJs/","content":"# EggJs单页面应用的基本实现\n\n  说到SPA（single page web application）单页面应用，想必各位前端Coder都不会陌生，不论是目前主流的React、Vue还是Angular都能够看到SPA的影子，但是很多开发和对于这个概念还是处于一种一知半解的状态，今天我们一起来学习研究一下SPA的简单实现。\n\n**先上github项目地址：** [Egg.js][1]\n\n![显示效果图](EggJs/urlChange.gif)\n\n## 背景介绍\n\n### 基础知识\n\n相信用过VUE.js开发SPA项目的小伙伴一定对路由跳转不陌生。浏览器的URL地址栏中的会有一个<span style=\"color:green\">“#”</span>标识符,同时在路由跳转的时候 #（锚部分：以下统称为路由）会发生变化，在页面不刷新的情况下渲染当前路由对应模块的代码。\n\n**那么这是怎么实现的呢**\n\n当然了实现对的方法其实有很多种，甚至你都可以使用Ajax/Fetch去做请求然后动态的修改页面结构，但是这样无异于增加工作量，其实还有更好的方法，就是使用<span style='color:#c7254e ;background-color: #f9f2f4'>*hash*</span>路由跟html5提供的<span style='color:#c7254e ;background-color: #f9f2f4'>*historyapi*</span>API。今天我们先使用hash路由也就是<span style='color:#c7254e ;background-color: #f9f2f4'>#</span>的方法来实现。\n\n首先我们先看看location对象给我们提供了哪些属性：\n\n![显示效果图](EggJs/location.png)\n\n[location对象][2]\n\n可见在location提供的第一个属性hash就是我们需要的，那么实现的大致方案就清晰了。\n\n## 实现方案\n\n- 获取location对象的hash属性并截取hash的路由跟可能存在的参数\n- 配置路由对应的代码\n- 根据路由加载不同的模块代码\n\n### 获取location的hash并分离路由跟参数\n\n通过使用String类型的split方法对hash进行字符串截取，从而分离路由跟可能存在的参数\n```Code block\n    Util_QsHasUrl = (hash) => {\n        const [, l] = hash.split('/');\n        const [u, p] = l.split('?');\n        let t = {};\n        if (p) {\n            p.split('&').forEach(item => {\n                const p = item.split('=');\n                t[`${p[0]}`] = p[1]\n            })\n        }\n        return {\n            u: u,\n            p: t ||{}\n        }\n    }\n```\n\n### 配置路由对应的文件\n\n#### 配置路由对应的文件并且导出\n\n```Code block\nimport Page1 from '../Pages/Page1/page1.js';\nimport Page2 from '../Pages/Page2/page2.js';\nimport Page3 from '../Pages/Page3/page3.js';\nimport Page4 from '../Pages/Page4/page4.js';\n\nconst routes=[{\n    routeName:'page1',\n    component:Page1\n},\n{\n    routeName:'page2',\n    component:Page2\n},\n{\n    routeName:'page3',\n    component:Page3\n},\n{\n    routeName:'page4',\n    component:Page4\n}];\n\nexport default routes;\n\n```\n\n\n#### 根据路由加载不同的模块代码\n\n- 此处的hashName对应代码一种返回值的u（urlHash）url获取的路由值\n\n- senData对应代码一种返回值的p(param) url截取的参数\n\n```Code block\ncheckPage = (hashName,senData) => {\n        let hasFoundRoute = false;\n        for (var i of (this.routeList)) {\n            if (i.routeName === hashName) {\n                hasFoundRoute = true;\n                console.log('find Module',i);\n               let renderModule= new i.component(senData);\n               this.targetRoot[0].innerHTML=renderModule.render();\n            }\n        }\n        if (!hasFoundRoute) {\n            this.targetRoot[0].innerHTML=NotFound();//预设的404模块\n        }\n    }\n```\n\n通过以上三部基本上就实现了单页面应用异步加载模块的功能\n\n具体代码可以参看[github地址][1]，欢迎大家评论，点赞。\n\n[1]: https://github.com/wilesen/Egg.js\n[2]:http://www.w3school.com.cn/jsref/dom_obj_location.asp","tags":["javaScript"],"categories":["javaScript","SPA"]}]